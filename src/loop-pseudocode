Loop Search Algorithm Description:

To find loops, a modified version of Dijkstra's Algorithm is used.

We create a queue of all cells that aren't of the colour we are trying to find a loop for. For example this queue would include all White and Empty cells if we were searching for a black loop. This queue marks all of these cells that are on the edges of the board as visited and adds them in the front of the queue and all other of these cells as unvisited and adds them at the end of the queue.

We then process this queue, popping elements from the start each time. For each of these elements we check to find unvisited neighbours and add them to the start of the queue, marking them as visited. If we find an unvisited node, we have found a loop so we return true. If we process this whole queue without finding an unvisited node, then we return false.

The queue searches the entire board from the edge inwards. This results in cells of the specified colour loop you want to find blocking the path of the search. Due to this, if a cell is unvisited it means that it was unreachable by the search and is hence fully enclosed and therefore a loop.

In the case of the entire board being filled by the colour you are searching for the queue will be empty and hence return false (no loop)

For the opposite case where the board is filled entirely by the colour you are not searching for, the queue will search every node, find no unvisited node and hence return false (no loop)


Loop Search Pseudocode:

searchForLoop(String colourToFind):boolean {
	nonColourCells <- all cells that are not of colour colourToFind
	H <- makeQueue(nonColourCells) // visited cells at start, unvisited at end

	while (H not empty) {
		oneCell <- H.pop() // pop from front of queue

		if (oneCell.visited not true) {
			return true
		}

		N <- oneCell.getNeighboursNotOfColour(colourToFind)

		for each neighbour in N {
			if (neighbour.visited not true) {
				H.addAtStart(neighbour)
			}
			H.visited <- true
		}
	}
	return false
}

Time Complexity: 
O(N) where N is the number of cells in the board (note that this is assuming nonColourCells is populated as the board is read in from input)

Every node is visited once as once it is visited, the visited value is set to true and it is never visited again.

For every node, there is a maximum of 6 neighbours (excluding edge nodes) which adds a constant factor onto the complexity (still O(N))

This is also assuming that the queue operations pop() (from start) and addAtStart() are all O(1)
